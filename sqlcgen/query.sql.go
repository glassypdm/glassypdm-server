// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const addMemberToPermissionGroup = `-- name: AddMemberToPermissionGroup :exec
INSERT INTO pgmembership(pgroupid, userid) VALUES(?, ?)
`

type AddMemberToPermissionGroupParams struct {
	Pgroupid int64  `json:"pgroupid"`
	Userid   string `json:"userid"`
}

func (q *Queries) AddMemberToPermissionGroup(ctx context.Context, arg AddMemberToPermissionGroupParams) error {
	_, err := q.db.ExecContext(ctx, addMemberToPermissionGroup, arg.Pgroupid, arg.Userid)
	return err
}

const checkProjectName = `-- name: CheckProjectName :one
SELECT COUNT(*) FROM project
WHERE teamid = ? and title=? LIMIT 1
`

type CheckProjectNameParams struct {
	Teamid int64  `json:"teamid"`
	Title  string `json:"title"`
}

func (q *Queries) CheckProjectName(ctx context.Context, arg CheckProjectNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkProjectName, arg.Teamid, arg.Title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectCommits = `-- name: CountProjectCommits :one
SELECT COUNT(commitid) FROM 'commit'
WHERE projectid = ?
LIMIT 1
`

func (q *Queries) CountProjectCommits(ctx context.Context, projectid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProjectCommits, projectid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPermissionGroup = `-- name: CreatePermissionGroup :exec
INSERT INTO permissiongroup(teamid, name) VALUES(?, ?)
`

type CreatePermissionGroupParams struct {
	Teamid int64  `json:"teamid"`
	Name   string `json:"name"`
}

func (q *Queries) CreatePermissionGroup(ctx context.Context, arg CreatePermissionGroupParams) error {
	_, err := q.db.ExecContext(ctx, createPermissionGroup, arg.Teamid, arg.Name)
	return err
}

const deletePermissionGroup = `-- name: DeletePermissionGroup :exec
DELETE FROM permissiongroup WHERE pgroupid = ?
`

func (q *Queries) DeletePermissionGroup(ctx context.Context, pgroupid int64) error {
	_, err := q.db.ExecContext(ctx, deletePermissionGroup, pgroupid)
	return err
}

const deleteTeamPermission = `-- name: DeleteTeamPermission :one
DELETE FROM teampermission
WHERE userid = ?
RETURNING userid, teamid, level
`

func (q *Queries) DeleteTeamPermission(ctx context.Context, userid string) (Teampermission, error) {
	row := q.db.QueryRowContext(ctx, deleteTeamPermission, userid)
	var i Teampermission
	err := row.Scan(&i.Userid, &i.Teamid, &i.Level)
	return i, err
}

const dropPermissionGroupMapping = `-- name: DropPermissionGroupMapping :exec
DELETE FROM pgmapping WHERE pgroupid = ?
`

func (q *Queries) DropPermissionGroupMapping(ctx context.Context, pgroupid int64) error {
	_, err := q.db.ExecContext(ctx, dropPermissionGroupMapping, pgroupid)
	return err
}

const dropPermissionGroupMembership = `-- name: DropPermissionGroupMembership :exec
DELETE FROM pgmembership WHERE pgroupid = ?
`

func (q *Queries) DropPermissionGroupMembership(ctx context.Context, pgroupid int64) error {
	_, err := q.db.ExecContext(ctx, dropPermissionGroupMembership, pgroupid)
	return err
}

const findProjectInitCommit = `-- name: FindProjectInitCommit :one
SELECT commitid FROM 'commit'
WHERE projectid = ?
ORDER BY commitid ASC LIMIT 1
`

func (q *Queries) FindProjectInitCommit(ctx context.Context, projectid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, findProjectInitCommit, projectid)
	var commitid int64
	err := row.Scan(&commitid)
	return commitid, err
}

const findTeamPermissions = `-- name: FindTeamPermissions :many
SELECT level FROM teampermission
WHERE userid = ?
`

func (q *Queries) FindTeamPermissions(ctx context.Context, userid string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findTeamPermissions, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var level int64
		if err := rows.Scan(&level); err != nil {
			return nil, err
		}
		items = append(items, level)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserInPermissionGroup = `-- name: FindUserInPermissionGroup :many
SELECT pgroupid FROM pgmembership WHERE
userid = ?
`

func (q *Queries) FindUserInPermissionGroup(ctx context.Context, userid string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findUserInPermissionGroup, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var pgroupid int64
		if err := rows.Scan(&pgroupid); err != nil {
			return nil, err
		}
		items = append(items, pgroupid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserManagedTeams = `-- name: FindUserManagedTeams :many
SELECT DISTINCT team.teamid, name FROM team INNER JOIN teampermission as tp ON team.teamid = tp.teamid
WHERE tp.userid = ? AND tp.level >= 2
`

type FindUserManagedTeamsRow struct {
	Teamid int64  `json:"teamid"`
	Name   string `json:"name"`
}

func (q *Queries) FindUserManagedTeams(ctx context.Context, userid string) ([]FindUserManagedTeamsRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserManagedTeams, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserManagedTeamsRow
	for rows.Next() {
		var i FindUserManagedTeamsRow
		if err := rows.Scan(&i.Teamid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserProjects = `-- name: FindUserProjects :many
SELECT projectid, title, name FROM project INNER JOIN team ON team.teamid = project.teamid
WHERE project.teamid = ?
`

type FindUserProjectsRow struct {
	Projectid int64  `json:"projectid"`
	Title     string `json:"title"`
	Name      string `json:"name"`
}

func (q *Queries) FindUserProjects(ctx context.Context, teamid int64) ([]FindUserProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserProjects, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserProjectsRow
	for rows.Next() {
		var i FindUserProjectsRow
		if err := rows.Scan(&i.Projectid, &i.Title, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserTeams = `-- name: FindUserTeams :many
SELECT DISTINCT team.teamid, name FROM team INNER JOIN teampermission AS tp ON team.teamid = tp.teamid
WHERE tp.userid = ?
`

type FindUserTeamsRow struct {
	Teamid int64  `json:"teamid"`
	Name   string `json:"name"`
}

func (q *Queries) FindUserTeams(ctx context.Context, userid string) ([]FindUserTeamsRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserTeams, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserTeamsRow
	for rows.Next() {
		var i FindUserTeamsRow
		if err := rows.Scan(&i.Teamid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommitInfo = `-- name: GetCommitInfo :one
SELECT
  a.cno,
  a.userid,
  a.timestamp,
  a.comment,
  a.numfiles,
  hehe.path,
  hehe.frno,
  hehe.filehash,
  hehe.blocksize
FROM
  'commit' a
  INNER JOIN (
    SELECT
      b.filehash,
      b.blocksize,
      fr.path,
      fr.frno,
      fr.commitid
    FROM
      filerevision fr
      INNER JOIN chunk b ON fr.filehash = b.filehash
    WHERE fr.commitid = ?
  ) hehe ON a.commitid = hehe.commitid
WHERE
  a.commitid = ? LIMIT 1
`

type GetCommitInfoParams struct {
	Commitid   int64 `json:"commitid"`
	Commitid_2 int64 `json:"commitid_2"`
}

type GetCommitInfoRow struct {
	Cno       sql.NullInt64 `json:"cno"`
	Userid    string        `json:"userid"`
	Timestamp int64         `json:"timestamp"`
	Comment   string        `json:"comment"`
	Numfiles  int64         `json:"numfiles"`
	Path      string        `json:"path"`
	Frno      sql.NullInt64 `json:"frno"`
	Filehash  string        `json:"filehash"`
	Blocksize int64         `json:"blocksize"`
}

// TODO Fix
func (q *Queries) GetCommitInfo(ctx context.Context, arg GetCommitInfoParams) (GetCommitInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getCommitInfo, arg.Commitid, arg.Commitid_2)
	var i GetCommitInfoRow
	err := row.Scan(
		&i.Cno,
		&i.Userid,
		&i.Timestamp,
		&i.Comment,
		&i.Numfiles,
		&i.Path,
		&i.Frno,
		&i.Filehash,
		&i.Blocksize,
	)
	return i, err
}

const getFileChunks = `-- name: GetFileChunks :many
SELECT blockhash, chunkindex FROM chunk
WHERE filehash = ?
`

type GetFileChunksRow struct {
	Blockhash  string `json:"blockhash"`
	Chunkindex int64  `json:"chunkindex"`
}

func (q *Queries) GetFileChunks(ctx context.Context, filehash string) ([]GetFileChunksRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileChunks, filehash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFileChunksRow
	for rows.Next() {
		var i GetFileChunksRow
		if err := rows.Scan(&i.Blockhash, &i.Chunkindex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileHash = `-- name: GetFileHash :one
SELECT filehash FROM filerevision
WHERE projectid = ? AND path = ? AND commitid = ? LIMIT 1
`

type GetFileHashParams struct {
	Projectid int64  `json:"projectid"`
	Path      string `json:"path"`
	Commitid  int64  `json:"commitid"`
}

func (q *Queries) GetFileHash(ctx context.Context, arg GetFileHashParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getFileHash, arg.Projectid, arg.Path, arg.Commitid)
	var filehash string
	err := row.Scan(&filehash)
	return filehash, err
}

const getLatestCommit = `-- name: GetLatestCommit :one
SELECT MAX(commitid) FROM 'commit'
WHERE projectid = ? LIMIT 1
`

func (q *Queries) GetLatestCommit(ctx context.Context, projectid int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestCommit, projectid)
	var max interface{}
	err := row.Scan(&max)
	return max, err
}

const getPermissionGroupMapping = `-- name: GetPermissionGroupMapping :many
SELECT p.projectid, p.title FROM pgmapping pg, project p
WHERE pg.pgroupid = ? AND pg.projectid = p.projectid
`

type GetPermissionGroupMappingRow struct {
	Projectid int64  `json:"projectid"`
	Title     string `json:"title"`
}

func (q *Queries) GetPermissionGroupMapping(ctx context.Context, pgroupid int64) ([]GetPermissionGroupMappingRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionGroupMapping, pgroupid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionGroupMappingRow
	for rows.Next() {
		var i GetPermissionGroupMappingRow
		if err := rows.Scan(&i.Projectid, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectInfo = `-- name: GetProjectInfo :one
SELECT title FROM project
WHERE projectid = ? LIMIT 1
`

func (q *Queries) GetProjectInfo(ctx context.Context, projectid int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getProjectInfo, projectid)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getProjectLivingFiles = `-- name: GetProjectLivingFiles :many
SELECT a.frid, a.path FROM filerevision a
INNER JOIN ( SELECT path, MAX(frid) frid FROM filerevision GROUP BY path ) b
ON a.path = b.path AND a.frid = b.frid
WHERE a.projectid = ? and changetype != 3
`

type GetProjectLivingFilesRow struct {
	Frid int64  `json:"frid"`
	Path string `json:"path"`
}

func (q *Queries) GetProjectLivingFiles(ctx context.Context, projectid int64) ([]GetProjectLivingFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectLivingFiles, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectLivingFilesRow
	for rows.Next() {
		var i GetProjectLivingFilesRow
		if err := rows.Scan(&i.Frid, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectState = `-- name: GetProjectState :many
SELECT a.frid, a.path, a.commitid, a.filehash, a.changetype, chunk.blocksize FROM chunk, filerevision a
INNER JOIN ( SELECT path, MAX(frid) frid FROM filerevision GROUP BY path ) b
ON a.path = b.path AND a.frid = b.frid
WHERE a.projectid = ? AND a.filehash = chunk.filehash
`

type GetProjectStateRow struct {
	Frid       int64  `json:"frid"`
	Path       string `json:"path"`
	Commitid   int64  `json:"commitid"`
	Filehash   string `json:"filehash"`
	Changetype int64  `json:"changetype"`
	Blocksize  int64  `json:"blocksize"`
}

func (q *Queries) GetProjectState(ctx context.Context, projectid int64) ([]GetProjectStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectState, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectStateRow
	for rows.Next() {
		var i GetProjectStateRow
		if err := rows.Scan(
			&i.Frid,
			&i.Path,
			&i.Commitid,
			&i.Filehash,
			&i.Changetype,
			&i.Blocksize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getS3Key = `-- name: GetS3Key :one
SELECT s3key FROM block
WHERE blockhash = ? LIMIT 1
`

func (q *Queries) GetS3Key(ctx context.Context, blockhash string) (string, error) {
	row := q.db.QueryRowContext(ctx, getS3Key, blockhash)
	var s3key string
	err := row.Scan(&s3key)
	return s3key, err
}

const getTeamByProject = `-- name: GetTeamByProject :one
SELECT teamid FROM project
WHERE projectid = ? LIMIT 1
`

func (q *Queries) GetTeamByProject(ctx context.Context, projectid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamByProject, projectid)
	var teamid int64
	err := row.Scan(&teamid)
	return teamid, err
}

const getTeamFromPGroup = `-- name: GetTeamFromPGroup :one
SELECT teamid FROM permissiongroup WHERE
pgroupid = ? LIMIT 1
`

func (q *Queries) GetTeamFromPGroup(ctx context.Context, pgroupid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamFromPGroup, pgroupid)
	var teamid int64
	err := row.Scan(&teamid)
	return teamid, err
}

const getTeamFromProject = `-- name: GetTeamFromProject :one
SELECT teamid FROM project
WHERE projectid = ? LIMIT 1
`

func (q *Queries) GetTeamFromProject(ctx context.Context, projectid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamFromProject, projectid)
	var teamid int64
	err := row.Scan(&teamid)
	return teamid, err
}

const getTeamMembership = `-- name: GetTeamMembership :many
SELECT userid, level FROM teampermission
WHERE teamid = ?
`

type GetTeamMembershipRow struct {
	Userid string `json:"userid"`
	Level  int64  `json:"level"`
}

func (q *Queries) GetTeamMembership(ctx context.Context, teamid int64) ([]GetTeamMembershipRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembership, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembershipRow
	for rows.Next() {
		var i GetTeamMembershipRow
		if err := rows.Scan(&i.Userid, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamName = `-- name: GetTeamName :one
SELECT name FROM team
WHERE teamid = ? LIMIT 1
`

func (q *Queries) GetTeamName(ctx context.Context, teamid int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getTeamName, teamid)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getTeamPermission = `-- name: GetTeamPermission :one
SELECT level FROM teampermission
WHERE teamid = ? AND userid = ?
LIMIT 1
`

type GetTeamPermissionParams struct {
	Teamid int64  `json:"teamid"`
	Userid string `json:"userid"`
}

func (q *Queries) GetTeamPermission(ctx context.Context, arg GetTeamPermissionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamPermission, arg.Teamid, arg.Userid)
	var level int64
	err := row.Scan(&level)
	return level, err
}

const getUploadPermission = `-- name: GetUploadPermission :one
SELECT COUNT(*) FROM teampermission
WHERE userid = ? LIMIT 1
`

func (q *Queries) GetUploadPermission(ctx context.Context, userid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUploadPermission, userid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertChunk = `-- name: InsertChunk :exec
INSERT INTO chunk(chunkindex, numchunks, filehash, blockhash, blocksize)
VALUES (?, ?, ?, ?, ?)
`

type InsertChunkParams struct {
	Chunkindex int64  `json:"chunkindex"`
	Numchunks  int64  `json:"numchunks"`
	Filehash   string `json:"filehash"`
	Blockhash  string `json:"blockhash"`
	Blocksize  int64  `json:"blocksize"`
}

func (q *Queries) InsertChunk(ctx context.Context, arg InsertChunkParams) error {
	_, err := q.db.ExecContext(ctx, insertChunk,
		arg.Chunkindex,
		arg.Numchunks,
		arg.Filehash,
		arg.Blockhash,
		arg.Blocksize,
	)
	return err
}

const insertCommit = `-- name: InsertCommit :one
INSERT INTO 'commit'(projectid, userid, comment, numfiles)
VALUES (?, ?, ?, ?)
RETURNING commitid
`

type InsertCommitParams struct {
	Projectid int64  `json:"projectid"`
	Userid    string `json:"userid"`
	Comment   string `json:"comment"`
	Numfiles  int64  `json:"numfiles"`
}

func (q *Queries) InsertCommit(ctx context.Context, arg InsertCommitParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertCommit,
		arg.Projectid,
		arg.Userid,
		arg.Comment,
		arg.Numfiles,
	)
	var commitid int64
	err := row.Scan(&commitid)
	return commitid, err
}

const insertFile = `-- name: InsertFile :exec
INSERT INTO file(projectid, path)
VALUES (?, ?)
`

type InsertFileParams struct {
	Projectid int64  `json:"projectid"`
	Path      string `json:"path"`
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) error {
	_, err := q.db.ExecContext(ctx, insertFile, arg.Projectid, arg.Path)
	return err
}

const insertFileRevision = `-- name: InsertFileRevision :exec
INSERT INTO filerevision(projectid, path, commitid, filehash, numchunks, changetype)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertFileRevisionParams struct {
	Projectid  int64  `json:"projectid"`
	Path       string `json:"path"`
	Commitid   int64  `json:"commitid"`
	Filehash   string `json:"filehash"`
	Numchunks  int64  `json:"numchunks"`
	Changetype int64  `json:"changetype"`
}

func (q *Queries) InsertFileRevision(ctx context.Context, arg InsertFileRevisionParams) error {
	_, err := q.db.ExecContext(ctx, insertFileRevision,
		arg.Projectid,
		arg.Path,
		arg.Commitid,
		arg.Filehash,
		arg.Numchunks,
		arg.Changetype,
	)
	return err
}

const insertHash = `-- name: InsertHash :exec
INSERT INTO block(blockhash, s3key, blocksize)
VALUES (?, ?, ?)
`

type InsertHashParams struct {
	Blockhash string `json:"blockhash"`
	S3key     string `json:"s3key"`
	Blocksize int64  `json:"blocksize"`
}

func (q *Queries) InsertHash(ctx context.Context, arg InsertHashParams) error {
	_, err := q.db.ExecContext(ctx, insertHash, arg.Blockhash, arg.S3key, arg.Blocksize)
	return err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO project(title, teamid)
VALUES (?, ?)
RETURNING projectid
`

type InsertProjectParams struct {
	Title  string `json:"title"`
	Teamid int64  `json:"teamid"`
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertProject, arg.Title, arg.Teamid)
	var projectid int64
	err := row.Scan(&projectid)
	return projectid, err
}

const insertTeam = `-- name: InsertTeam :one
INSERT INTO team(name)
VALUES (?)
RETURNING teamid
`

func (q *Queries) InsertTeam(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertTeam, name)
	var teamid int64
	err := row.Scan(&teamid)
	return teamid, err
}

const insertTwoFileRevisions = `-- name: InsertTwoFileRevisions :exec
INSERT INTO filerevision(projectid, path, commitid, filehash, numchunks, changetype)
VALUES (?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?)
`

type InsertTwoFileRevisionsParams struct {
	Projectid    int64  `json:"projectid"`
	Path         string `json:"path"`
	Commitid     int64  `json:"commitid"`
	Filehash     string `json:"filehash"`
	Numchunks    int64  `json:"numchunks"`
	Changetype   int64  `json:"changetype"`
	Projectid_2  int64  `json:"projectid_2"`
	Path_2       string `json:"path_2"`
	Commitid_2   int64  `json:"commitid_2"`
	Filehash_2   string `json:"filehash_2"`
	Numchunks_2  int64  `json:"numchunks_2"`
	Changetype_2 int64  `json:"changetype_2"`
}

func (q *Queries) InsertTwoFileRevisions(ctx context.Context, arg InsertTwoFileRevisionsParams) error {
	_, err := q.db.ExecContext(ctx, insertTwoFileRevisions,
		arg.Projectid,
		arg.Path,
		arg.Commitid,
		arg.Filehash,
		arg.Numchunks,
		arg.Changetype,
		arg.Projectid_2,
		arg.Path_2,
		arg.Commitid_2,
		arg.Filehash_2,
		arg.Numchunks_2,
		arg.Changetype_2,
	)
	return err
}

const isUserInPermissionGroup = `-- name: IsUserInPermissionGroup :one
SELECT userid FROM pgmembership pgme, pgmapping pgma WHERE
pgme.userid = ? AND pgma.projectid = ? AND pgma.pgroupid = pgme.pgroupid
`

type IsUserInPermissionGroupParams struct {
	Userid    string `json:"userid"`
	Projectid int64  `json:"projectid"`
}

func (q *Queries) IsUserInPermissionGroup(ctx context.Context, arg IsUserInPermissionGroupParams) (string, error) {
	row := q.db.QueryRowContext(ctx, isUserInPermissionGroup, arg.Userid, arg.Projectid)
	var userid string
	err := row.Scan(&userid)
	return userid, err
}

const listPermissionGroupForTeam = `-- name: ListPermissionGroupForTeam :many
SELECT pg.pgroupid as pgroupid, pg.name as pgroup_name, p.title as project_title, p.projectid as project_id
FROM permissiongroup pg, project p, pgmapping pgm WHERE
pg.teamid = ? AND pg.pgroupid = pgm.pgroupid AND pgm.projectid = p.projectid AND p.teamid = pg.teamid
`

type ListPermissionGroupForTeamRow struct {
	Pgroupid     int64  `json:"pgroupid"`
	PgroupName   string `json:"pgroup_name"`
	ProjectTitle string `json:"project_title"`
	ProjectID    int64  `json:"project_id"`
}

func (q *Queries) ListPermissionGroupForTeam(ctx context.Context, teamid int64) ([]ListPermissionGroupForTeamRow, error) {
	rows, err := q.db.QueryContext(ctx, listPermissionGroupForTeam, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPermissionGroupForTeamRow
	for rows.Next() {
		var i ListPermissionGroupForTeamRow
		if err := rows.Scan(
			&i.Pgroupid,
			&i.PgroupName,
			&i.ProjectTitle,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissionGroupMembership = `-- name: ListPermissionGroupMembership :many
SELECT userid FROM pgmembership WHERE pgroupid = ?
`

func (q *Queries) ListPermissionGroupMembership(ctx context.Context, pgroupid int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listPermissionGroupMembership, pgroupid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var userid string
		if err := rows.Scan(&userid); err != nil {
			return nil, err
		}
		items = append(items, userid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCommits = `-- name: ListProjectCommits :many
SELECT cno, numfiles, userid, comment, commitid, timestamp FROM 'commit'
WHERE projectid = ?
ORDER BY commitid DESC
LIMIT 5 OFFSET ?
`

type ListProjectCommitsParams struct {
	Projectid int64 `json:"projectid"`
	Offset    int64 `json:"offset"`
}

type ListProjectCommitsRow struct {
	Cno       sql.NullInt64 `json:"cno"`
	Numfiles  int64         `json:"numfiles"`
	Userid    string        `json:"userid"`
	Comment   string        `json:"comment"`
	Commitid  int64         `json:"commitid"`
	Timestamp int64         `json:"timestamp"`
}

func (q *Queries) ListProjectCommits(ctx context.Context, arg ListProjectCommitsParams) ([]ListProjectCommitsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCommits, arg.Projectid, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectCommitsRow
	for rows.Next() {
		var i ListProjectCommitsRow
		if err := rows.Scan(
			&i.Cno,
			&i.Numfiles,
			&i.Userid,
			&i.Comment,
			&i.Commitid,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapProjectToPermissionGroup = `-- name: MapProjectToPermissionGroup :exec
INSERT INTO pgmapping(pgroupid, projectid) VALUES(?, ?)
`

type MapProjectToPermissionGroupParams struct {
	Pgroupid  int64 `json:"pgroupid"`
	Projectid int64 `json:"projectid"`
}

func (q *Queries) MapProjectToPermissionGroup(ctx context.Context, arg MapProjectToPermissionGroupParams) error {
	_, err := q.db.ExecContext(ctx, mapProjectToPermissionGroup, arg.Pgroupid, arg.Projectid)
	return err
}

const removeHash = `-- name: RemoveHash :exec
DELETE FROM block WHERE blockhash = ?
`

func (q *Queries) RemoveHash(ctx context.Context, blockhash string) error {
	_, err := q.db.ExecContext(ctx, removeHash, blockhash)
	return err
}

const removeMemberFromPermissionGroup = `-- name: RemoveMemberFromPermissionGroup :exec
DELETE FROM pgmembership WHERE pgroupid = ? AND userid = ?
`

type RemoveMemberFromPermissionGroupParams struct {
	Pgroupid int64  `json:"pgroupid"`
	Userid   string `json:"userid"`
}

func (q *Queries) RemoveMemberFromPermissionGroup(ctx context.Context, arg RemoveMemberFromPermissionGroupParams) error {
	_, err := q.db.ExecContext(ctx, removeMemberFromPermissionGroup, arg.Pgroupid, arg.Userid)
	return err
}

const removeProjectFromPermissionGroup = `-- name: RemoveProjectFromPermissionGroup :exec
DELETE FROM pgmapping WHERE pgroupid = ? AND projectid = ?
`

type RemoveProjectFromPermissionGroupParams struct {
	Pgroupid  int64 `json:"pgroupid"`
	Projectid int64 `json:"projectid"`
}

func (q *Queries) RemoveProjectFromPermissionGroup(ctx context.Context, arg RemoveProjectFromPermissionGroupParams) error {
	_, err := q.db.ExecContext(ctx, removeProjectFromPermissionGroup, arg.Pgroupid, arg.Projectid)
	return err
}

const setTeamPermission = `-- name: SetTeamPermission :one
INSERT INTO teampermission(userid, teamid, level)
VALUES(?, ?, ?) ON CONFLICT(userid, teamid) DO UPDATE SET level=excluded.level
RETURNING userid, teamid, level
`

type SetTeamPermissionParams struct {
	Userid string `json:"userid"`
	Teamid int64  `json:"teamid"`
	Level  int64  `json:"level"`
}

func (q *Queries) SetTeamPermission(ctx context.Context, arg SetTeamPermissionParams) (Teampermission, error) {
	row := q.db.QueryRowContext(ctx, setTeamPermission, arg.Userid, arg.Teamid, arg.Level)
	var i Teampermission
	err := row.Scan(&i.Userid, &i.Teamid, &i.Level)
	return i, err
}
